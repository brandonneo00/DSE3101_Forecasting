?arrange
knitr::opts_chunk$set(include = TRUE, message = FALSE, warning = FALSE,
fig.align = "center",  out.width = "80%")
library(tidyverse)
library(readxl)
library(stringr)
library(lubridate)
?arrange
?count
?cor
?select
?geom_errorbar
?geom_histogram
?geom_point()
?geom_area
library(ggplot2)
library(dplyr)
?dplyr::near
near(179, 179.00000000000000001)
near(179, 179.00000000000000001)
install.packages("forcats")
library(forcats)
data(gss_cat)
str(gss_cat)
gss_cat
fct_count(gss_cat$marital)
fct_count(gss_cat$marital, sort = TRUE)
fct_unique(gss_cat$marital)
View(hdi_df_americas)
#Get unique values in the factor.
fct_unique(gss_cat$marital)
fct_infreq(gss_cat$marital)
#Arrange the levels of a factor based on each level’s frequency.
fct1 <- fct_infreq(gss_cat$marital)
fct1
fct_unique(fct1)
#Reverse the order of levels.
fct2 <- fct_rev(fct1)
fct_unique(fct2)
library(stringr)
# Create a string
names <- c("Python", "SPSS", "Stata", "Julia") # Match strings that contain a lower case "t" str_view_all(names, "t")
# Match strings that contain a lower case "t"
str_view_all(names, "t")
month.abb
month.name
fruit[1:5]
#We can combine or concatenate two strings with str_c().
string1 <- "A string with numbers (12, 1500, and 102)!"
string2 <- "Another string."
string3 <- str_c(string1, string2, sep = " ")
string3
#We can zip together vectors of strings.
str_c(month.abb, month.name, sep = " stands for ")
# We can subset a string with str_sub() with a particular position in the string.
str_sub(fruit[1:5], 1, 3)
# These can be useful when extracting information from dates.
some_dates <- c("2009/01/01","2008-12-15","20010903")
str_sub(some_dates, 1, 4)
# What are the locations with the fruits with “berry” in their names?
str_which(fruit, "berry")
#Then we can get the exact names of these fruits.
fruit[str_which(fruit, "berry")]
# The subset() function combines these two steps.
str_subset(fruit, "berry")
str_replace(fruit, "berry", "fish")
# For every fruit with “berry” in its name, change it to “fish”.
# Replace a pattern
str_replace(fruit, "berry", "fish")[str_which(fruit, "berry")]
#Match none of the characters.
str_subset(fruit, "[ˆcde]berry")
# Match over a range of characters.
str_subset(fruit, "[a-n]berry")
# We get different results when we escape or don’t escape.
# any single character
str_extract_all(string3, ".")
# a period
str_extract_all(string3, "\\.")
# We get different results when we escape or don’t escape.
string3
string4 <- c("today is a wednesday", "today is a wednesday 3")
str_detect(string4, pattern = "^t.*wednesday\\s[0-9]$")
str_detect(string4, pattern = "^t")
str_detect(string4, pattern = "^t.")
str_detect(string4, pattern = "^t.*wednesday")
str_detect(string4, pattern = "^t.*wednesday\\s")
str_detect(string4, pattern = "^t.*wednesday\\s[0-9]")
# * matches the previous pattern 0 or more times.
# Match digits
string3
str_extract_all(string3, "[0-9]")
str_extract_all(string3, "*[0-9]")
str_extract_all(string3, "[0-9]*")
str_extract_all(string3, "[0-9]+")
# We can also specify the number of matches precisely.
# One or more of the previous pattern
str_extract_all(string3, "[0-9]{3,}")
install.packages("readr")
install.packages("readr")
library(readr)
install.packages("readr")
install.packages("readr")
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
library(dplyr)
#install.packages("readr")
library(readr)
# Read the output in your Console. The \n is indicating new lines.
txt
txt <- read_file("../data/wk3_nasa.txt") txt
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
library(dplyr)
# ▶ Read the output in your Console. The \n is indicating new lines.
txt
library(readr)
txt <- read_file("../data/wk3_nasa.txt")
txt
txt <- read_file("../data/wk3_nasa.txt")
txt
# ▶ Read the output in your Console. The \n is indicating new lines.
txt
# ▶ Let’s try to take out the budget categories and numbers from the text file.
str_extract_all(txt, "[0-9]+")
library(stringr)
# ▶ Let’s try to take out the budget categories and numbers from the text file.
str_extract_all(txt, "[0-9]+")
# ▶ The expression [0-9]+ separates numbers at the thousand-separating comma. The numbers returned are not really dollar amounts.
# ▶ Let’s try get everything that starts with $, followed by one or more strings of commas or digits.
# ▶ The dollar sign $ needs to be escaped.
str_extract_all(txt, "\\$[,0-9]+")
# How about the bullet numbers enclosed in parentheses?
str_extract_all(txt, "\\([,0-9]\\)")
str_extract_all(txt, "\\(d\\)")
str_split(txt, "\\n")
# Let’s now split the text into lines.
str_split(txt, "\\n")
str_extract_all(txt, "\\(\\d\\)")
txt_split <- str_split(txt, "\\n")[[1]]
txt_split
# The information on budget and numbers are in items 3-11.
txt_split[3:11]
# The pattern we need: Character string starts with (number) and end with a period.
items <- str_extract_all(txt, "\\(\\d\\).+\\.")[[1]]
items
str_match(items, "For\\s(.+),\\s\\$")
str_match(items, "\\$([,\\d]+)")
# Get rid of the commas, and turn it into numeric.
money <- as.numeric(str_replace_all(money, ",", ""))
# Now let’s extract the money amount.
money <- str_match(items, "\\$([,\\d]+)")
money <- money[, 2]
money
# Get rid of the commas, and turn it into numeric.
money <- as.numeric(str_replace_all(money, ",", ""))
money
# Let’s make it into a data frame.
items <- data.frame(purpose = for_items, amount = money)
items
# Let’s make it into a data frame.
items <- data.frame(purpose = for_items, amount = money)
# Use str_match() to identify the pattern we need.
# ▶ It returns a character matrix. The budget categories names are in its second column.
for_items <- str_match(items, "For\\s(.+),\\s\\$")
for_items <- for_items[, 2]
for_items
# Let’s make it into a data frame.
items <- data.frame(purpose = for_items, amount = money)
items
# For every fruit with “berry” in its name, change it to “fish”.
# Replace a pattern
str_replace(fruit, "berry", "fish")[str_which(fruit, "berry")]
# Match any one of the characters in the square brackets.
str_subset(fruit, "[cde]berry")
# We get different results when we escape or don’t escape.
# any single character
str_extract_all(string3, ".")
# a period
str_extract_all(string3, "\\.")
string4 <- c("today is a wednesday", "today is a wednesday 3")
str_detect(string4, pattern = "ˆt.*wednesday\\s[0-9]$")
string4 <- c("today is a wednesday", "today is a wednesday 3")
string4 <- c("today is a wednesday", "today is a wednesday 3")
str_detect(string4, pattern = "ˆt.*wednesday\\s[0-9]$")
str_detect(string4, pattern = "^t.*wednesday\\s[0-9]$")
install.packages("pdftools")
install.packages("pdftools")
library(pdftools)
txt <- pdf_text("../data/wk3_pnas.pdf")
txt
#Examine the object txt. Notice that it is a character vector with an entry for each page.
#▶ The table we want is in the second element.
tables <- txt[2]
# Examine this object in your Console
tables
# Examine this object in your Console
tables
tabs
# ▶ It is a long string. Each line on the page are separated by \n.
# ▶ With str_split(), we create a list with the lines of the text as elements. ▶ With the simplify = TRUE argument inside, we obtain a character string.
# Split string by new line ("\n")
tabs <- str_split(tables, "\n", simplify = TRUE) %>% # trim leading space
str_trim()
tabs
class(tabs)
tabs
# First few lines of the "tabs" object
head(tabs, 16)
# ▶ We find that information for variable names is in the 3rd and 5th lines.
tabs[3]
#Let’s convert the 3rd line into appropriate column names.
tabs[3] %>%
# Remove anything following the comma
str_replace_all(",\\s.", "") %>%
# Split string when there are two or more spaces
str_split("\\s{2,}", simplify = TRUE) -> names1
names1
tabs[3] %>%
# Remove anything following the comma
str_replace_all(",\\s.", "")
tabs[3] %>%
# Remove anything following the comma
str_replace_all(",\\s.", "") %>%
# Split string when there are two or more spaces
str_split("\\s{2,}", simplify = TRUE)
names1
# Let’s do the same for the 5th entry:
tabs[5]
tabs[5] %>%
# Split string when there is any space
str_split("\\s+", simplify = TRUE) -> names2
names2
# Let’s convert the 3rd line into appropriate column names.
tabs[3]
str_c(rep(names1, each = 3), names2[-1], sep = "_")
names1
rep(names1, each = 3)
names2
names2[-1]
# ▶ Column names:
colnames <- c(names2[1], names3) %>%
# Convert to lower case
str_to_lower() %>%
# Replace white space with underscore "_"
str_replace_all("\\s", "_")
# We can join these names to generate one name for each column.
names3 <- str_c(rep(names1, each = 3), names2[-1], sep = "_")
names3
# ▶ Column names:
colnames <- c(names2[1], names3) %>%
# Convert to lower case
str_to_lower() %>%
# Replace white space with underscore "_"
str_replace_all("\\s", "_")
colnames
# Now we are ready to get the actual data.
# ▶ By examining the tabs object, we find that the information is in lines 7-16.
tabs[7:16]
tabs[7:16] %>%
str_split("\\s{2,}", simplify = TRUE)
tabs[7:16] %>%
str_split("\\s{2,}", simplify = TRUE) %>%
data.frame()
tabs[7:16] %>%
str_split("\\s{2,}", simplify = TRUE) %>%
data.frame() %>%
setNames(colnames)
tabs[7:16] %>%
str_split("\\s{2,}", simplify = TRUE) %>%
data.frame() %>%
setNames(colnames) %>%
# Convert everything (except for the first column) into numeric
mutate_at(-1, parse_number) -> table_s1
table_s1
tabs[28:30] %>%
str_split("\\s{2,}", simplify = TRUE) %>% data.frame() %>%
setNames(colnames) %>%
mutate_at(-1, parse_number)
# Column names
names1 <- tabs[24] %>% str_replace_all(",\\s.", "") %>% str_split("\\s{2,}", simplify = TRUE)
names2 <- tabs[26] %>% str_split("\\s+", simplify = TRUE)
names3 <- str_c(rep(names1, each = 3), names2[-1], sep = "_")
colnames <- c(names2[1], names3) %>% str_to_lower() %>% str_replace_all("\\s", "_")
# Values & data frame
tabs[28:30] %>%
str_split("\\s{2,}", simplify = TRUE) %>% data.frame() %>%
setNames(colnames) %>%
mutate_at(-1, parse_number) -> table_s2
table_s2
library(dplyr)
library(ggplot)
library(ggplot2)
library(readxl)
q1_df = read.csv("ARDataLags-1137.xslx")
q1_df
q1_df = read.csv("ARDataLags-1137.xslx")
q1_df
q1_df = read.csv("ARDataLags-1137")
q1_df = read.csv("ARDataLags-1137.xlsx")
q1_df
?read_excel
q1_df = read_excel("ARDataLags-1137.xlsx")
q1_df
q1_df = read_excel("ARDataLags-1137.xlsx", range = "A2:B40")
q1_df
cov()
?cov
var(q1_df$Y)
q2_df = read_excel("TimeSerCat-9134.xlsx")
q2_df
q1_df
colnames(q2_df) = ("t", "Y")
q2_df = read_excel("TimeSerCat-9134.xlsx", range = "A2:B82")
q2_df
ggplot(q2_df) +
geom_point(x=t, y= Y)
ggplot(q2_df, aes(x = t, y = Y)) +
geom_point()
q2_new_df = read_csv("TimeSerCat-1764.csv")
q2_new_df = read.csv("TimeSerCat-1764.csv")
q2_new_df = read.csv("TimeSerCat-1764.csv")
q2_new_df
ggplot(q2_new_df, aes(x = t, y = Y)) +
geom_point()
getwd()
setwd("../../Y3S2")
getwd()
setwd("DSE3101/Project/DSE3101_Forecasting")
getwd()
library(shiny); runApp('working merging 11apr 7.30pm.R')
runApp('working merging 11apr 7.30pm.R')
runApp('working merging 11apr 7.30pm.R')
runApp('working merging 11apr 7.30pm.R')
getwd()
runApp()
getwd()
runApp()
runApp()
reticulate::py_last_error()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
qnorm(mean = 0.3, sd = 0.016)
runApp()
# Read the Excel file using the correct file path
path_to_data = "ROUTPUTQvQd.xlsx"
gdp_raw <- read_excel(path_to_data, col_names = TRUE)
# Convert all columns except the first one (which contains dates) to numeric, keeping NA values as NA
gdp_num <- gdp_raw[, 2:ncol(gdp_raw)]
gdp_num <- mutate_all(gdp_num, as.numeric)
gdp_date <-gdp_raw[,1]
# Repeat the transformation code for each column in gdp_num
transformation_codes <- rep(5, ncol(gdp_num))
# Apply the fred_transform function with the transformation codes
stat_gdp <- fred_transform(data = gdp_num, type = "fred_qd", code = transformation_codes, na.rm= FALSE)
stat_df = data.frame(gdp_date, stat_gdp)
stat_df$DATE = zoo::as.yearqtr(stat_df$DATE, format = "%Y:Q%q")
stat_df
get_last_available_vintage(stat_gdp)
get_last_available_vintage = function(stat_df_w_date){
last_available_datapt = stat_df_w_date %>%
select(DATE) %>%
tail(1) %>%
pull()
last_available_vintage = seq(last_available_datapt, length.out = 2, by = 1/4)[2]
last_available_vintage
last_available_vintage_year = str_split(last_available_vintage, pattern=" ")[[1]][1]
last_available_vintage_year_prefix = substr(last_available_vintage_year, start = 3, stop = 4)
last_available_vintage_quarter = str_split(last_available_vintage, pattern=" ")[[1]][2]
col_prefix = "ROUTPUT"
last_available_vintage_col_name = paste(col_prefix, last_available_vintage_year_prefix, last_available_vintage_quarter, sep="")
return(last_available_vintage_col_name)
}
get_last_available_vintage(stat_gdp)
stat_gdp
get_last_available_vintage(stat_df)
substr(get_last_available_vintage(stat_df), start=-4, stop=-3)
?substr
last_vintage_year = substr(last_vintage, start = nchar(last_vintage) - 4, end = nchar(last_vintage))
substr(get_last_available_vintage(stat_df), start=nchar(), stop=-3)
last_vintage = get_last_available_vintage(stat_df)
last_vintage = get_last_available_vintage(stat_df)
last_vintage_year = substr(last_vintage, start = nchar(last_vintage) - 4, stop = nchar(last_vintage))
last_vintage_year
last_vintage_year = substr(last_vintage, start = nchar(last_vintage) - 3, stop = nchar(last_vintage))
last_vintage_year
last_vintage_year = substr(last_vintage, start = nchar(last_vintage) - 3, stop = nchar(last_vintage) - 1)
last_vintage_year
last_vintage = get_last_available_vintage(stat_df)
last_vintage_year = substr(last_vintage, start = nchar(last_vintage) - 3, stop = nchar(last_vintage) - 2)
last_vintage_year
as.integer(paste("20", last_vintage_year, sep=""))
last_vintage_quarter = substr(last_vintage, start = nchar(last_vintage) - 2, stop = nchar(last_vintage))
last_vintage_quarter
last_vintage_quarter = substr(last_vintage, start = nchar(last_vintage) - 1, stop = nchar(last_vintage))
last_vintage_quarter
last_vintage = get_last_available_vintage(stat_df)
last_vintage_year = substr(last_vintage, start = nchar(last_vintage) - 3, stop = nchar(last_vintage) - 2)
#earliest_year = min(as.integer(format(stat_df$DATE, "%Y")))
last_vintage_year = as.integer(paste("20", last_vintage_year, sep=""))
last_vintage_quarter = substr(last_vintage, start = nchar(last_vintage) - 1, stop = nchar(last_vintage))
last_vintage_year
last_vintage_quarter
all_poss_quarters = c("Q1", "Q2", "Q3", "Q4")
setdiff(all_poss_quarters, last_vintage_quarter)
c("Q1", "Q2", "Q3", "Q4")
runApp()
runApp()
runApp()
if (1==1 & 2==2){}
1==1 & 2==2
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
?round
round(0.23232323, 5)
stat_df
stat_df %>% select(ROUTPUT99Q3)
stat_df %>% select(ROUTPUT99Q3) %>% round(ROUTPUT99Q3, 3)
stat_df %>% select(ROUTPUT99Q3) %>% mutate(ROUTPUT99Q3 = round(ROUTPUT99Q3, 3))
runApp()
runApp()
# test_adl_model
# test_adl_backtesting = ADLbacktest("10", "Q1", test_adl_model, stat_gdp, gdp_date, hstart_gdp, hstart_date, 2, 8)
# average_backtest_test_result = average_backtest("10", "Q1", test_adl_model, stat_gdp, gdp_date, hstart_gdp, hstart_date, 2, 8)
# average_backtest_test_result
# average_backtest_test_result$actual_values
# average_backtest_test_result$rf_predictions_vector
# average_backtest_test_result$adl_predictions_vector
# average_backtest_test_result$ar_predictions_vector
# average_backtest_test_result$average_predictions
library(bslib)
ui <- fluidPage(
## Inserting background image
tags$head(
tags$style(
HTML(
"
#background-image {
position: fixed;
top: 0;
left: 0;
width: 100%;
height: 100%;
z-index: -1;
}
"
)
)
),
# Embedding the image using HTML img tag
tags$img(src = "lightsciencebackground.jpg", id = "background-image", alt = "Background Image"),
# Application title
titlePanel("Experimenting with Macroeconomic Forecasting: Real GDP Change"),
h4("Welcome to the forefront of macroeconomic forecasting."),
h4("Step into our innovative lab, where we blend scientific rigour with economic analysis to navigate the complex terrain of GDP forecasting."),
h3("Let the experiment begin!"),
theme = shinythemes::shinytheme("united"),
# Sidebar with a slider input for number of bins
sidebarLayout(
sidebarPanel(
sliderInput("year", "Select Year", min=1975, max=last_vintage_year, step=1, value = 2010),
selectInput("quarter", "Select Quarter", choices=c("Q1", "Q2", "Q3", "Q4")),
selectInput("alpha", "Select Alpha for Fan Chart", choices=c("50%", "80%", "90%"), selected="50%"),
selectInput("model_choice", "Choose Model to show", choices = c("Autoregressive Model (AR)", "Autoregressive Distributed Lag Model (ADL)", "Random Forest", "Combined", "Most Optimal"), selected = "AR"),
checkboxInput("hide_line_point", "Show Actual Change", value = FALSE),
tags$img(src = "forecast-analytics.png", height = 200, width = 200),
tags$img(src = "experiment.png", height = 200, width = 200)
),
# Show a plot of the generated distribution
mainPanel(
tabsetPanel(
tabPanel("Time Series", fluidRow(plotlyOutput("line_plot"),  tableOutput("table_forecast")), textOutput("plot_description"),
conditionalPanel(condition = "input.model_choice == 'Random Forest'", plotOutput("rf_feature_importance"))),
tabPanel("Historical Data", DT::DTOutput("dt_table")),
# Add a new tab for Statistics with Data Table
tabPanel("Statistics",
h4("Statistics Table"),
DT::DTOutput("stats_table")
)
),
# Add a new picture below the plot description and mirror it
tags$img(src = "Teacher_teaching_with_a_stick.svg", height = 200, width = 200, style = "transform: scaleX(-1);")
)
),
actionButton("show_about", "About")
)
# test_adl_model
# test_adl_backtesting = ADLbacktest("10", "Q1", test_adl_model, stat_gdp, gdp_date, hstart_gdp, hstart_date, 2, 8)
# average_backtest_test_result = average_backtest("10", "Q1", test_adl_model, stat_gdp, gdp_date, hstart_gdp, hstart_date, 2, 8)
# average_backtest_test_result
# average_backtest_test_result$actual_values
# average_backtest_test_result$rf_predictions_vector
# average_backtest_test_result$adl_predictions_vector
# average_backtest_test_result$ar_predictions_vector
# average_backtest_test_result$average_predictions
library(bslib)
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
getwd()
shiny::runApp()
